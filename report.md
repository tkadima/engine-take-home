**Report**

When building this content feed application, my goal was to create a functional application that not only meets the requirements but also showcases my ability to build an application that is efficient, scalable, and user-friendly.

Although using a database was not explicitly required by the spec, I chose to use MongoDB mainly for performance reasons. Having a database allows me to clean and transform data once before storing it. This approach makes the backend more efficient by eliminating the need to clean and transform data repeatedly for each request. Setting up MongoDB with Next.js is straightforward and not time-consuming, making this decision practical.

My strategy for cleaning and transforming the data was straightforward. The two required properties for content cards are `id` and `imageUri`. The `imageUri` field has a default value and a match pattern, so my data cleaning function validates these fields. For `id`, I added an if-statement to ensure the field is populated; for `imageUri`, I check that it matches the pattern or assign a default value. Optional fields are set to predictable defaults: empty strings for text, null for dates, and 0 for numbers. I also trimmed non-null strings for consistency and standardization.

To ensure the API endpoint's efficiency, I seeded the database multiple times to evaluate performance with large data volumes. Observing latency and high bandwidth usage led me to implement pagination and indexing to improve efficiency. Pagination prevents bandwidth overload, thus reducing latency, while indexing the priority field speeds up the sorting operation. On the server side, I used connection caching to avoid the overhead of creating a new connection for each query.

For the front end, I used MUIâ€™s Joy library due to my familiarity with MUI and because its documentation includes an example content card that mirrors Instagram. I ensured that all data was displayed in ways that felt most relevant. With no specific design in mind, I allowed myself to have fun with the UI. I used the priority field to represent "likes" and made the "subtitle" the alt text for images. The rest is intuitive, including a modal that pops up to display comments, similar to Instagram. To make the app user-centric, I focused on error handling by researching the SWR React hook. In addition to its built-in error handling, it automatically caches data and revalidates it in the background, leading to a more efficient, responsive, and user-friendly experience.

Most of the challenges I faced with this project involved configuration. I had some difficulty getting the unit tests for the data cleaning method to work. The `cleanAndNormalizeData` function is in an `.mjs` file, which requires proper setup to handle both `.mjs` and `.ts` files. I resolved this by creating a `jest.config.mjs` file with specific configurations to use `babel-jest` for `.mjs` files and `ts-jest` for TypeScript files. Additionally, I updated `package.json` to ensure Jest treats these files correctly. I configured Babel with a `.babelrc` file to handle ES module syntax. These changes ensured that Jest could correctly process and run the tests. Setting up the test for `data.test.ts` also took some research to properly mock the MongoDB client.